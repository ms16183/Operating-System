<!--ts-->
   * [OSの役割](#osの役割)
      * [オペレーティングシステムの役割](#オペレーティングシステムの役割)
      * [主記憶装置](#主記憶装置)
      * [補助記憶装置](#補助記憶装置)
      * [OS](#os)
      * [容易性](#容易性)
      * [効率性](#効率性)
      * [ハードウェアリソースの多重化と効率化](#ハードウェアリソースの多重化と効率化)
      * [リアルタイム処理](#リアルタイム処理)
      * [分散処理](#分散処理)
   * [CPUの仮想化](#cpuの仮想化)
      * [プロセスとその処理形態](#プロセスとその処理形態)
      * [プロセスの状態](#プロセスの状態)
      * [割り込み](#割り込み)
      * [スーパバイザコール割り込み](#スーパバイザコール割り込み)
      * [外部割り込み](#外部割り込み)
      * [割り込みによるプロセスの中断と再開](#割り込みによるプロセスの中断と再開)
      * [スレッド](#スレッド)
      * [実行中のプロセスの中断方式](#実行中のプロセスの中断方式)
      * [到着順スケジューリング](#到着順スケジューリング)
      * [処理時間順スケジューリング](#処理時間順スケジューリング)
      * [優先度順スケジューリング](#優先度順スケジューリング)
      * [ラウンドロビンスケジューリング](#ラウンドロビンスケジューリング)
      * [多重レベルフィードバックスケジューリング](#多重レベルフィードバックスケジューリング)
   * [並行プロセス](#並行プロセス)
      * [並行プロセスの影響](#並行プロセスの影響)
      * [プロセス競合](#プロセス競合)
      * [プロセス協調](#プロセス協調)
      * [プロセス干渉](#プロセス干渉)
      * [排他制御](#排他制御)
      * [Dekkerのアルゴリズム(排他制御)](#dekkerのアルゴリズム排他制御)
      * [割り込み制御による排他制御](#割り込み制御による排他制御)
      * [ハードウェアによる排他制御](#ハードウェアによる排他制御)
      * [セマフォ(Semaphore)](#セマフォsemaphore)
      * [プロセス協調問題](#プロセス協調問題)
      * [MUTEX](#mutex)
      * [プロデューサ・コンシューマ問題](#プロデューサコンシューマ問題)
      * [リーダライタ問題](#リーダライタ問題)
      * [ダイニングフィロソフィア問題](#ダイニングフィロソフィア問題)
      * [モニタ](#モニタ)
      * [モニタによるLock機構](#モニタによるlock機構)
      * [モニタによるCondition機構](#モニタによるcondition機構)
      * [モニタの利点と欠点](#モニタの利点と欠点)
   * [主記憶管理](#主記憶管理)
      * [マルチプログラミング方式実現の問題点](#マルチプログラミング方式実現の問題点)
      * [主記憶管理の目的](#主記憶管理の目的) * [物理アドレスと論理アドレスの変換](#物理アドレスと論理アドレスの変換)
      * [下限レジスタ機構](#下限レジスタ機構)
      * [ロック/キー機構](#ロックキー機構)
      * [プログラム実行時の主記憶領域の確保](#プログラム実行時の主記憶領域の確保)
      * [固定区画方式の問題点](#固定区画方式の問題点)
      * [可変区画方式の問題点](#可変区画方式の問題点)
      * [可変区画方式における空き領域の管理](#可変区画方式における空き領域の管理)
      * [リスト構造による空き領域の管理](#リスト構造による空き領域の管理)
      * [ビットマップ方式による空き領域の管理](#ビットマップ方式による空き領域の管理)
      * [実行可能形式](#実行可能形式)
      * [プログラムのロードと領域の再配置](#プログラムのロードと領域の再配置)
      * [オーバーレイ](#オーバーレイ)
      * [仮想アドレス](#仮想アドレス)
      * [ページング](#ページング)
      * [ページテーブル](#ページテーブル)
      * [ページングの問題点](#ページングの問題点)
      * [セグメンテーション](#セグメンテーション)
      * [ページ化セグメンテーション](#ページ化セグメンテーション)
      * [多重レベルページング](#多重レベルページング)
      * [0レベルページング](#0レベルページング)
      * [ページフォールト割り込み](#ページフォールト割り込み)
      * [スワップスケジューリング](#スワップスケジューリング)
      * [デマンドページング](#デマンドページング)
      * [プリページング](#プリページング)
      * [スワップアウトする場所](#スワップアウトする場所)
      * [参照頻度表](#参照頻度表)
      * [更新タイミング変更](#更新タイミング変更)
      * [フェーズ化現象](#フェーズ化現象)
   * [ファイル](#ファイル)
      * [ファイルによる2次記憶の管理](#ファイルによる2次記憶の管理)
      * [テープ型デバイス](#テープ型デバイス)
      * [アジマス角](#アジマス角)
      * [ディスク型デバイス](#ディスク型デバイス)
      * [階層化ディレクトリシステム](#階層化ディレクトリシステム)
      * [リンク](#リンク)
      * [固定長割り当て方式](#固定長割り当て方式)
      * [連続領域割り当て方式](#連続領域割り当て方式)
      * [ディスクキャッシュ](#ディスクキャッシュ)
      * [ライトスルー方式](#ライトスルー方式)
      * [ライトバック方式](#ライトバック方式)
      * [非同期入出力](#非同期入出力)
      * [ファイルシステムの仮想化](#ファイルシステムの仮想化)
      * [FAT(File Allocation Table)](#fatfile-allocation-table)
      * [i-node](#i-node)
      * [ext3(Third Extended File System)](#ext3third-extended-file-system)
      * [ジャーナリング](#ジャーナリング)

<!--te-->

# OSの役割

## オペレーティングシステムの役割
- 演算装置: データに対する演算を行う．
- 制御装置: 各装置を制御する制御信号を出す．
- 記憶装置: プログラムやデータを記憶する．
- 入力装置: コンピュータに外部からデータを入力する．
- 出力装置: コンピュータから外部にデータを出力する．
- LSI: Large Scale Integrated circuit．1チップの大規模集積回路．
- MPU: Licro Processing Unit．マイクロプロセッサ．
- 4004: 1971年にIntelがリリースした4bitCPU．
- 8086: 1978年に8bitCPU．x86の基礎．

## 主記憶装置
- 揮発性メモリ RAM(Random Access Memory)
  - DRAM(Dynamic RAM)
  - SRAM(Static RAM)

- 不揮発性メモリ ROM(Read Only Memory)
  - マスクROM
  - PROM(Programmable ROM)
  - EPROM(Erastable PROM)
  - EEPROM(Electrical EPROM)

## 補助記憶装置
- 補助記憶装置
  - HDD(Hard Disk Drive)
  - SSD(Solid State Drive)
  - ODD(Optical Disk Drive)

## OS
- アプリケーションプログラムにとって容易かつ効率的に利用可能とする一連のプログラムのこと．基本プログラムと呼ぶ．
- ハードウェアリソース: CPU，メモリ，入出力装置
- ソフトウェアリソース: ソフトウェアの使用権など
- 応用プログラム: ブラウザ，ワープロソフト，シェル
- オペーレーティングシステムの目的: **"容易性"と"効率性"の向上**である．

## 容易性
- ハードウェアへのアクセス
  - プログラム側がハードウェア操作しやすくなるインターフェイスを用意．
  - 入出力装置に対する簡単なアクセス．
- ハードウェアリソースの確保
  - プログラム別にハードウェアリソースの確保に対する制御．
  - 仮想化による無数のハードウェアリソースを提供する．

## 効率性
- ハードウェアリソースの共有
  - プログラムアクセス時の適切なスケジューリング
- ソフトウェアリソース管理
  - 最低限のソフトウェア実行，ソフトウェアリソースのバージョン管理
- プログラミング作成支援
  - ライブラリ管理，ユーザインターフェイス支援．
- 統合的なコンピュータシステム環境
  - ネットワークに結合したコンピュータのハードウェア・ソフトウェアリソース．
    - 例えばプリンタ．LAN内のPCから印刷できる．

## ハードウェアリソースの多重化と効率化
- 時分割多重化
  - 時間軸で多重化．ハードウェアリソースを複数プログラムに交互利用．
- 空間分割多重化
  - 空間軸上での多重化．ハードウェアリソースを複数の領域に区切り各プログラムに割り当てる．
    - メモリはこの例である．

- バッチ処理: プログラム実行前に一括投入されたジョブに含まれる情報のみによって処理を行う方式．
  - **ターンアラウンドタイム(TAT)**: ジョブが待ち行列に投入されてから終了するまでの時間．
  - 実行に必要なリソースが小さいジョブを優先すると平均TATが少なくなって効率的である．
- インタラクティブ処理: プログラム実行中に入力が必要となった時，ユーザの入力を行いプログラムの実行を制御する処理方式．
  - **スループット**: コンピュータが単位時間当たりに処理できる能力．
  - **TSS**: 複数のプロセスに非常に短い時間単位でCPUの実行権を与えて，各プロセスにCPUを占有させているように見せかける仮想化手法．
  - **レスポンスタイム**: インタラクティブな入力を受けて処理結果を返却するまでの時間．
  - スパコンではバッチ処理が優先される．メインフレームでは対話処理にリソースを優先．

## リアルタイム処理
- ジョブやプロセスが発生し，決められた時間内に実行を保証．
- レスポンスタイムの変動要素をできる限り排除．
- リアルタイム性を担保できるハードウェアリソース．
  - 工場のロボット制御．
  - 音声・映像のメディア処理．
  - ATMシステム，飛行機の予約システム．

## 分散処理
- ネットワークを通じて複数のコンピュータを同時に用いて処理を行う．
- クライアントサーバモデル．
- コンピュータ間でのファイル共有．
- 分散コンピューティング．

# CPUの仮想化

## プロセスとその処理形態
- **プロセス**: 実行プログラムに対するリソースの割り当て単位
- ユニプロセッサ・ユニプログラミング方式
  - 1個のCPU上で一つのプロセスの開始から終了までを継続して処理する．
- ユニプロセッサ・マルチプログラミング方式
  - 主記憶内に複数のプログラムを格納し，入出力の完了またはOSからの命令によりプログラムを切り替えて実行する．
- マルチプロセッサ・マルチプログラミング方式
  - 複数のCPUを備えたコンピュータを対象とし，複数CPUで同時にプログラムを実行する．
- スレッド・CPUリソースを論理的な単位で割り当て
  - プロセスは多数のスレッドを内部に生成できる．
  - 複数スレッドは同時実行される複数の実行ポイントが存在する．
  - プログラムに並列性がある場合，一つのプロセス内で同時に複数CPUを使用可能．

## プロセスの状態
- **実行状態(running)**
  - CPUリソースを含む実行に必要なすべてのリソースが確保され，プロセスを実行している状態．
- **実行可能状態(ready)**
  - CPUリソースさえ確保できればプロセスを実行可能な状態．
- **待ち状態(wait)**
  - CPU以外に実行に必要なリソースが確保されていない状態．

## 割り込み
- CPUが高速化つ軽量にイベントを処理するプログラム実行方式．
  - イベントは，CPU内で通常の計算処理以外の事象．
- 内部割り込み
  - SVC割り込み
  - プログラムチェック割り込み
- 外部割り込み
  - 入出力割り込み
  - タイマ割り込み
  - マシンチェック割り込み
  - リスタート割り込み
- 実行速度の差
  - 人の反応速度: 約10^(-1) sec
  - HDDのR/W速度: 約10^(-3) sec
  - メモリのR/W速度: 約10^(-7) sec
  - CPUの1命令実行速度: 約10^(-9) sec

## スーパバイザコール割り込み
- スーパバイザコール(SVC)割り込み
  - ユーザプログラムがOSに対して処理を依頼する際に発生する割り込み．
  - 入出力関数内でSVC割り込みを呼び出し，OSへ処理を依頼する．
  - スーパバイザモード
    - OSを実行するモードをCPUが有するすべての命令とOSが管理するすべてのリソースを利用可能．
  - ユーザモード
    - ユーザが作成した応用プログラムを実行するモード．実行できる命令や利用リソースに制限あり．
- プログラムチェック割り込み(例外割り込み)
 - 実行中のプログラムで異常が発生した時に発生する割り込み．
  - ゼロ除算
  - オーバーフロー
  - 不正アドレスアクセス
- プログラム実行時の異常を適切に対処することが可能．

## 外部割り込み
- 入出力割り込み
  - 入出力装置から発生する割り込み．
  - OSが2次記憶装置に書き込み依頼し，書き込みが終了した際に発生する2次記憶装置からの割り込み．
- タイマ割り込み
  - タイムシェアリングシステムにおいて，各プロセスに割り当てられたクオンタムの終了時など，時間を制御するインターバルタイマによる割り込み．
- マシンチェック割り込み
  - ハードウェアによって通知される異常．
    - CPU温度上昇
    - 冷却装置の異常
    - その他電源などの異常
- リスタート割り込み
  - コンピュータシステムをリスタート(リセット)する際に発生する割り込み．

## 割り込みによるプロセスの中断と再開
- 割り込みが発生すると，実行中のプロセスが中断され，割り込み処理ルーチン(割り込みハンドラ，割り込み処理プログラム)が実行される．
  - プロセスAがCPUスケジューラに対して入出力命令を依頼して割り込みが発生(SVC命令)．
- **PSW(プログラム状態語)**
  - CPU内のプロセスの再開に必要なレジスタ情報．
- **PCB(プロセス制御ブロック)**
  - 割り込みが発生した時に実行していたプロセスの情報が保存される領域．
    - プロセスの識別子
    - PSW
    - ユーザ名
    - 実行優先度
    - 既実行時間
    - リソース情報
  - 固定領域にして，速度を上げる処置をとっている．
- コンテキスト処理
- PSWのロード，ストアに関する一連の処理．
  1. PSW退避後に割り込み処理ルーチンがCPUスケジューラを呼び出し次に実行するプロセスを決定する．
  1. 次にOSが次に実行するプロセスのPSWをCPUに転送し，プロセスを再開する．

## スレッド
- CPUリソースのみを独立に割り当てる．
  - マルチスレッド
    - 各スレッドは独自にレジスタ軍とスタックを持ち，CPUリソースを割り当てる．
    - プロセス内で管理される主記憶，プログラム領域，静的変数領域，動的変数領域，PSWが各スレッド間で共有する．
    - ファイル情報もプロセス単位で管理する．
    - CPU内に複数のコアがある場合，それぞれでスレッドを作成し，並列実行が可能．

## 実行中のプロセスの中断方式
- **プリエンプション方式**
  - OSが実行中のプロセスの実行権を強制的に取り上げプロセスを中断する．
  - プリエンティブなマルチタスク(Win, Mac, UNIXが採用)

- **ノンプリエンプション方式**
  - OSではなく実行中のプロセスが**自主的**にCPUリソースをOSに戻す．
  - プログラムが暴走した場合，プロセスが自主的にCPUリソースを変換できずシステム断の可能性あり．
  - ノンプリエンプティなマルチタスク(Win95, MacOS9が採用)

- OSの効率性は，CPUスケジューリングアルゴリズムの性能でほぼ決定する．
  - 理想は応答時間・待ち時間が最小，CPU使用率・スループットが最大．
- CPUリソースは時間分割し仮想化する．
  - プロセスの切り替えが増加．
  - 次に実行するプロセスを選択する操作も増加．
- 切り替えによるオーバヘッドの増加．
  - コンピュータシステムのスループットが低下．
  - スケジューリング方法でオーバーヘッドの増減を調整．

- スケジューリングアルゴリズムの効率化の指標
  - 応答時間
    - **ターンアラウンドタイム(TAT)**: パッチ処理におけるジョブ投入から結果受け取りまでの時間．
    - レスポンスタイム: 対話処理における端末からの入力から結果受け取りまでの時間．
  - **スループット**
    - CPUが単位時間に行うユーザに有益な仕事量．
    - プロセス切り替えなどのオーバヘッドは含まれない．
    - 入出力操作やコンテキスト切り替えなどを提言し計算処理にCPUリソースを用いるとスループットが向上．
  - 待ち時間
    - プロセスが完了するまでに実行可能キューで待つ時間(実行可能状態から実行できるまでの時間)
  - CPU使用率
    - `CPUの動作時間 / システム稼働時間`

## 到着順スケジューリング
- FIFO方式である．
- 最初に到着したプロセスが終了までリソースを占有する．プロセスの処理時間を考慮しない．

## 処理時間順スケジューリング
- プロセスの処理時間が小さいものから割り当てる方式．
- 実際は，各プロセスの処理時間を事前に知ることはできない．
- 応答時間を理論上で最短にできる．

## 優先度順スケジューリング
- 優先度を**nice**という値で決める．
- niceが小さいほど優先度が高い．
- 動的優先度
  - プロセス実行中に優先度が変化するスケジューリング．
  - 既実行時間，待ち時間で優先度を変化させる．
  - 入出力操作直後のプロセスに対して優先度を高くする．
  - **スタベーション**: プロセスの待ち時間に応じて優先度を変化させるエージング方式による動的優先スケジューリングを適用する．
    - **エージング方式**が一般的らしい．
- 静的優先度
  - プロセス生成時にあらかじめ指定した優先度によってスケジューリングを行う．

## ラウンドロビンスケジューリング
- 実行中プロセスにクオンタムが割り当てられる．これを使い果たすとプリエンプションする．
- 割り当てCPU利用可能時間(クオンタム)終了後，CPUスケジューラの割り込みでプロセスを中断し，待ち行列の末尾に追加する．

## 多重レベルフィードバックスケジューリング
- 優先度で分けられた複数の待ち行列を用いる．
- クオンタムを得たプロセスは優先度が低い待ち行列に移される
- 複数のクオンタムを必要とするプロセスは優先度が下がる．

# 並行プロセス

## 並行プロセスの影響
- プロセス競合
  - 有限なリソースを取り合う状態．
  - 適切にリソースを割り当てなければならない．
- プロセス協調
  - 複数プロセスがお互いを助け合う処理．
  - 複数プロセスが同期している．
- プロセス干渉
  - 他プロセスの影響により現在のプロセスに異常が発生する状態．
  - プログラムのバグが原因であることが多い．

## プロセス競合
- リソースに関する共有変数があるとする．
  - プロセスAが共有変数をリードし，ライトするまでの間にプリエンプションなどによりプロセスBが共有変数を読んでしまう．
- **クリティカルセクション**: ロード，ストア間などアトミックにしなければならない一連の処理．
- **MUTEX**: クリティカルセクション等を他のプロセスと排他的に実行する制御のこと．

## プロセス協調
- プロセス間通信
  - 通信の仕組みがない場合，送受信双方でタイミングを合わせる．
    - フラグによって送信をしなかったり受信をしなかったりする．
    - 通信バッファを設けて一時的に通信情報を保存する．

## プロセス干渉
- 緊急度の高いプロセスが実行されたため，別プロセスがスワップアウトされる場合など．

## 排他制御
- MUTEX
- 即時性
  - クリティカルセクションの実行時に競合するプロセスが存在しないとき，プロセスは即クリティカルセクションを行うようにする．
- 公平性
  - 他プロセスのクリティカルセクションの実行を妨げることができない．
- デッドロック防止
  - 競合プロセスが存在しようとも，永遠に待たされることがない．

- エントリーシーケンス(Entry Sequence)
  - クリティカルセクションに入る権利を獲得する処理．
  - クリティカルセクションをフラグで管理し，クリティカルセクション開始時にフラグを変更する．

- エグジットシーケンス(Exit Sequence)
  - クリティカルセクションを終了する準備を行う処理．

## Dekkerのアルゴリズム(排他制御)
- Interest
  - 2つのプロセスがクリティカルセクションに興味があるかを示す．
- Priority
  - 2つのプロセスがクリティカルセクションに同時に興味があった場合，どちらが優先するかを決める．
- 問題点
  - ユーザプログラムに依存し過ぎている．
  - クリティカルセクション実行中，片方のプロセスはずっと待ち状態であるためCPUリソースを無駄に消費する**ビジーウェイト**に陥る．
    - **スピンロック**: 複数プロセスの場合，積極的にこの待ち方をする．
  - 3つ以上のプロセスが同時に実行される環境では細かい優先度設定が困難である．
  - OoO実行とは反する．

## 割り込み制御による排他制御
- 割り込みのみがプロセスの中断を発生させる．
  - そのためクリティカルセクション実行時のエントリーシーケンスで，割り込み実行禁止命令を実行する．
  - エグジットシーケンスで割り込み実行禁止命令が解除される．
- 問題点
  - 大規模システムだと，頻繁に割り込みが発生する．
  - 割り込み実行禁止が増えるとOSの実行自由度が低下する．
  - OS停止の可能性がある．

## ハードウェアによる排他制御
- テストアンドセット命令
  - TAS命令
  - あるメモリ位置へアトミックに書き込みできる命令．
    - つまり，プリエンプションが行われない．
  - Dekkerのアルゴリズムよりも単純である．

## セマフォ(Semaphore)
- ダイクストラが提案したプログラミングの手法．オランダ語で"腕木通信"が語源．
- プロセス間同期機構
  - 整数型であるセマフォ変数，待ち行列からなる構造体である．
  - P操作: リソースの獲得．許可されない場合は待ち状態へ移行する．セマフォ変数をデクリメントする．
  - V操作: リソースの解放．まちプロセスを実行可能状態へ移行する．セマフォ変数をインクリメントする．

## プロセス協調問題
- [MUTEX](#mutex)
- [プロデューサ・コンシューマ問題](#プロデューサコンシューマ問題)
- [リーダライタ問題](#リーダライタ問題)
- [ダイニングフィロソフィア問題](#ダイニングフィロソフィア問題)

## MUTEX
- セマフォによる排他制御．

```
Semaphore mutex = 1;

P(mutex); // -
// クリティカルセクション
V(mutex); // +
```

## プロデューサ・コンシューマ問題
- [プロセス協調](#プロセス協調)の例と同じ．
  - フラグで送受信を管理する．
- リング型バッファ
  - バッファをn個設ける．
  - 送信側はバッファ`i`番に送信データを書き込んで，`i`の値を増加．
  - 受信側はバッファ`j`番に受信データを読み込んで，`j`の値を増加．
  - n-1番は0番に繋がっている(つまり，`i=(i+1)%n`, `j=(j+1)%n`である)．
  - リング上を送信側と受信側が回っていて，データを書き込んだり読み込んだりしているように見える．

## リーダライタ問題
- ライタによる書き込み中はリーダは読み込めない．
- ライタが書き込みを行なっていない場合，複数のリーダが読み出し可能．
- リーダとは反対に，同時に複数のライタを使用できない．

## ダイニングフィロソフィア問題
- 5台のコンピュータが5台のテープ装置に競合アクセスする同期問題のモデル．
- Candy/Misraの解法を用いれば，任意のプロセス，任意のリソースの確保可能かつデッドロックが発生しない．

## モニタ
- セマフォとオブジェクト指向プログラミングによる排他制御．
- モニタ内へのリソースにアクセスする場合はコンパイル時にチェックされる．

```
class Monitor{
  private int num;

  public Monitor(int n){
    num = n;
  }

  void increment(){
    num += 1;
  }

  void decrement(){
    num -= 1;
  }
}

// 複数プロセスに共有される．
Monitor monitor = new Monitor(1);

monitor.decrement();
// クリティカルセクション
monitor.increment();
```

- 共有変数へのアクセスはメソッドからのみ．
- 排他制御のためのコードを記述しなくても良い．

## モニタによるLock機構

```
class Monitor{
  private int reader;
  private int writer;
  private bool busy;

  void Monitor(){
    reader = 0;
    writer = 0;
    busy = false;
  }

  public void start_read(){
    while(writer != 0){
      reader += 1;
    }
  }

  public void finish_read(){
    if(reader > 0){
      reader -= 1;
    }
  }

  public void start_write(){
    writer += 1;
    while(busy || reader != 0){};
    busy = true;
  }

  publiv void finish_write(){
    if(writer > 0){
      writer -= 1;
    }
    busy = false;
  }
}

// Lock機構
Monitor lock;
```

## モニタによるCondition機構

```
class Monitor{
  // 待ち行列
  private Mat mat;

  public Monitor(mat m){
    mat = m;
  }

  // 別プロセスが待ち状態に移行する原因となった条件変数に対して
  // signalを実行するまで自分は待ち状態に移行する．
  public void wait(){
    // プロセスを待ち行列に追加する．
  }

  // 条件変数にしたいしてwaitメソッドを実行したことにより待ち状態のプロセスがある場合は
  // そのうちの1つを実行可能状態にする．
  public void signal(){
    // 待ち行列からプロセスを選択する．
    // 選択したプロセスは実行可能である．
  }

  // シグナル全プロセスバージョン
  public void signal_all(){
    // 待ち行列のプロセスを全て実行可能にする．
  }

  // 待ち状態のプロセスが存在するか否か．
  public bool queue(){
    // 待ち行列にプロセスが存在するか否か．
    return mat.length > 0;
  }
}

// Condition機構
Monitor cond;
```

## モニタの利点と欠点
- 利点
  - 排他制御するべきリソースを明示化できる．
  - オブジェクト指向であるため可読性，保守性が高い．
  - リソースに空きがない場合，待ち状態になるか否かを自由に選択できる．
  - コンパイル時にエラーが検出できる(ただし完璧ではない)．

- 欠点
  - モニタを言語レベルでサポートしているものは少ない．
    - Java
    - Mesa
    - Python，NET Framework，Squeak Smalltalkではライブラリがある．

# 主記憶管理

## マルチプログラミング方式実現の問題点
- 主記憶内のデータを保護する機能がない．
- プロセスが使用できるメモリ量は主記憶の大きさに制限される．
- 主記憶を管理する必要がある．

## 主記憶管理の目的
- **主記憶のアクセス権を決定**する．
- 主記憶管理を行うハードウェアを**主記憶管理部(MMU)**と呼ぶ．
  - ユーザに独立した**論理アドレス空間**を提供する．
  - 物理アドレスと論理アドレスを変換する．
  - 論理アドレスには条件がある．
    - 大きさが無制限である．
    - プロセス毎に，固有の空間を用意し，アクセス保護を行う．
    - プログラム部，データ部，スタック部等を分離する．
    - プロセス間でアドレスを共有する([通信機構](#リーダライタ問題))．

## 物理アドレスと論理アドレスの変換
- ネーミング関数
  - 変数名のような識別子を論理アドレスに変換する．
  - コンパイル，リンク時に行う．
- メモリ関数
  - 論理アドレスから物理アドレスに変換する．
  - OSが変換する．
- 内容関数
  - 物理アドレスからそのアドレスに格納された内容に変換する．
  - ハードウェアが変換する．

## 下限レジスタ機構
- ユーザプログラムが使用できる記憶領域の下限を下限レジスタに設定する．
  - OS領域にアクセスできないようにしている．
  - ユーザモードのみに適用される．
- アドレスレジスタ(ADR)と下限レジスタを比較器で比較する．
- 領域の境界が一意に固定される．
- OS領域保護の役割以外を持たない．
- 複数プロセス間でのアクセス権は設定できない．

## ロック/キー機構
- プログラムがアドレスレジスタで指定したアドレスを主記憶管理部側が分割する．
- 主記憶は，アドレス上位部が同一値である部分領域ごとのブロックに，仮想的に分割する．
  - 上位部(キー部)
    - アクセス権が格納されているインデックスの値
  - 下位部(ロック部)
    - 実際の領域(OS領域，ユーザ領域，データ領域)が保存されているメモリのアドレス．
    - 例えば，インデックス3番のデータは0x**3**000~0x**3**999にある．

## プログラム実行時の主記憶領域の確保
- 主記憶領域の確保は他プロセスと協調する必要がある．
- 要求
  - 静的領域要求
    - プログラム実行開始時にプログラムとデータを転送するために必要な領域を確保する要求．
  - 動的領域要求
    - プログラム実行中，必要な分のメモリを確保する要求．
- 区画サイズ
  - 固定区画方式
    - プロセスに割り当てる領域の大きさを決めておく．
  - 可変区画方式
    - プロセス毎に割り当てる領域の大きさは決まっていない．

## 固定区画方式の問題点
- リソースを多く使用するプロセスに領域を割り当てるのが難しい．

## 可変区画方式の問題点
- **フラグメンテーション**が発生する．
  - 統計的には`プロセスの数/2`が無駄になる．**1/2ルール**と呼ばれる．
  - **メモリコンパクション**: デフラグ．断片化した領域を連続領域にまとめる．
    - メモリコンパクションを行うには，ほぼ全てのプロセスを停止する必要があるため困難．
- 空き領域の探索が困難である．
  - とあるプロセスの空き領域に合わせた確保が難しい．

## 可変区画方式における空き領域の管理
- **ベストフィット方式**
  - 領域を割り当てた後の残り領域が最も少ない空き領域を割り当てる．
  - 探索に時間がかかる．
  - 小さな空き領域が増加し，大きな領域要求に対応できなくなる．
- **ファーストフィット方式**
  - 最初に発見したプロセスからのメモリ要求領域を格納するのに十分な空き領域を割り当てる．
  - 探索に時間がかからない．
  - アドレス上位に大きい領域が残るため，大きな領域要求にも対応できる．
- **ワーストフィット方式**
  - 領域割り当て後の残り領域が一番大きい空き領域を割り当てる．
  - 空き領域が均一化されているため大きな領域を確保できない．
  - 主記憶領域の使用効率が低下する．

## リスト構造による空き領域の管理
- リスト構造で管理する．

```
struct EMPTY{
  // アドレス
  // 長さ
  // ポインタ
}
```

- ベストフィット方式であれば，大きさを基準に昇順に挿入する．
- ファーストフィット方式であれば，アドレス順に昇順に挿入する．

## ビットマップ方式による空き領域の管理
- 配列のこと．
- 配列のインデックスとメモリアドレスが対応している．
  - 配列のインデックスが5番なら0x**5**000~0x**5**999までを管理する．
- 配列の中には，インデックスに対応したメモリアドレスの区間が空き領域か否かを表す(真偽値のような)値が入っている．
- 配列であるためランダムアクセスによりリスト構造よりも高速である．

## 実行可能形式
- ソースコードをコンピュータは直接理解できない．機械語に変換する必要がある．
  - 実行可能形式はELF(Linux)，PE(Windows)など．
- コンパイラ
  - ソースコードからオブジェクトファイルを生成する．
- リンカ
  - オブジェクトファイルやライブラリを結合する．
- **ライブラリ**
  - 共通の処理として必要なものをまとめたファイル．
  - どのプログラムでも共有できる．
  - 動的リンク
    - プログラム実行中にライブラリを読む．
  - 静的リンク
    - コンパイル後，プログラム中にライブラリを埋め込む(容量大)．

```
$ ls
main.c  lib.c

$ gcc -c lib.c # ライブラリをコンパイルする．

$ ar r libstatic.a lib.o # アーカイバでオブジェクトファイルを静的ライブラリにアーカイブする．

$ gcc -L $PWD -lstatic -o main main.c # Lオプションは静的ライブラリの絶対パス指定．コンパイル，リンクする．

$ ./main # 実行する．

```

## プログラムのロードと領域の再配置
- **リロケータブル**
  - 主記憶上のどの位置に読み込まれても実行可能である．
  - つまり，プログラム内のアドレスはすべて相対的に書かれている．
- **ダイナミックリンク**
  - コンパイル時に一切のリンクを操作せず，実行時にリンク操作を行う．
  - ライブラリ更新時にはライブラリを更新するだけで良い．
- **リエントラント**
  - 複数のプログラムが主記憶上に読み込まれた関数を同時に利用できる．
  - プログラム内の関数でプリエンプションが発生しても他プログラムはその関数を利用できる必要がある．
  - プログラム内の関数でプリエンプションが発生してもプリエンプション直後から同一関数を再開できる．
  - 自身のコードを書き換えない．
  - リエントラントでないプログラムを呼び出さない．
  - 静的変数や大域変数を使わない．

```
$ echo "int main(){ int a = 0; return 0; }" > main.c
$ gcc -O0 -o main main.c
$ objdump -d -M intel main

0000000100000f9e <_main>:
   100000f9e:	55                   	push   rbp
   100000f9f:	48 89 e5             	mov    rbp,rsp
   100000fa2:	c7 45 fc 00 00 00 00 	mov    DWORD PTR [rbp-0x4],0x0
   100000fa9:	b8 00 00 00 00       	mov    eax,0x0
   100000fae:	5d                   	pop    rbp
   100000faf:	c3                   	ret

$
```
- 変数`a`は，rbpレジスタから相対的に4バイト分(=`sizeof(int)`)上方向に確保されている．

## オーバーレイ
- 主記憶を時間的に共有するために，指定した時間にプログラムが必要とする部分を主記憶上に存在させる制御方法．
- 新しい関数は，必要とされなくなった関数に上書きされる．
- 処理が複雑である．
- プログラム側で関数を主記憶に転送する制御が必要．

## 仮想アドレス
- 主記憶の動的再配置によりプロセスが用いることができるメモリ資源を無限大に見せる方法．
- **仮想アドレス**: 記憶容量が無限大の論理アドレス．
- **スワップイン**
  - 実行中のプログラムがある時点で必要となる領域を2次記憶から主記憶上にインする操作．
- **スワップアウト**
  - 実行中のプログラムで必要のない領域を主記憶から2次記憶にアウトする操作．
  - スワップイン時，ディスクから主記憶上に転送する領域を確保するために行う．

## ページング
- [ロック/キー機構](#ロックキー機構)に動的再配置の機能を加えた方式．
- 仮想アドレスを上位ビットの**ページ番号部**と下位アドレスの**オフセット部**に分割する．
  - 仮想アドレスは**ページ**と呼ばれるブロック単位に分割される．
  - 物理アドレスは**ページフレーム**と呼ばれるブロック単位に分割される．

## ページテーブル
- ページ番号からページフレームへの変換を行う配列．
- 分割したページ番号部が配列のインデックス番号である．
- 配列のデータには，フラグがある．
  - Vフラグ: ページが主記憶上に存在する．あるいは2次記憶上に存在する．
    - 2次記憶にあるときは**ページフォールト割り込み**後に，スワップインする．
  - Pフラグ: 読み込み(r)001，書き込み(w)010, 実行(x)100のOR演算だから000~111の数値．
  - Cフラグ: スワップイン後に書き込みがあるか否か．
    - 書き込みがあればスワップアウト次に2次記憶へのフレームの書き戻しがいる．
  - ページフレーム番号: ページフレームのインデックス番号．

## ページングの問題点
- フラグメンテーションの解決とその問題
  - ページという単位でブロック化されているためフラグメンテーションが発生しない．
  - 主記憶全体の空き容量が十分でも新しいプロセスに連続した領域を割り当てられない．
    - 統計的に，`全領域数 / 3`が無駄になる．
  - **内部フラグメンテーション**: プロセスに割り当てられた複数ページの中で最後に割り当てたページが使われない問題．
    - 実際，ページのサイズは4~8kBであるため無視できる．
- ページテーブルが巨大化する．
  - ページテーブルをハッシュ関数でハッシュすることで解決する．
  - 連想レジスタ方式により，メモリアドレスの増大に対処する．
- メモリアクセスの増大
  - ページテーブルが主記憶内に存在し，ページテーブルへのアクセス及び物理アドレスへのアクセスと2回アクセスしなければならない．
- ページングの条件で実現できない部分
  - 論理アドレス空間をプログラム部，データ部，スタック部などに分離できない．
  - 複数プロセス間で，アドレス空間を共有する共有メモリの実装ができない．

## セグメンテーション
- **セグメント**と呼ばれる，論理的に独立したそれぞれの論理アドレス空間のサイズを自由に増減できるブロックを割り当てる手法．
- 各プロセスに対して複数のセグメントを割り当てる．
- 仮想アドレス空間上では，プログラム領域，データ領域，スタック領域などのセグメントがバラバラに存在する．
  - そのためプログラムからはそれぞれが独立した空間に見える．
- ページングと同様，セグメントテーブルによって仮想アドレスと物理アドレスとを変換する．
  - Vフラグ
  - 基底アドレス
  - セグメント長

## ページ化セグメンテーション
- ページングとセグメンテーションの利点を合わせたもの．
  - ページングの目的: ブロック単位で管理し，フラグメンテーションを解決する．
  - セグメンテーションの解決: アドレス空間の共有，保護．
- マルチプログラミング環境で用いられる主記憶管理方法の主流である．
- セグメントがページ単位で構成される．
- セグメントの相対アドレスがページングの仮想アドレスに相当する．
- 手順
  1. 仮想アドレスがセグメント番号部，ページ番号部，オフセット部に分割される．
  1. セグメント番号部がインデックス番号としてセグメントテーブルを参照する．
  1. セグメントテーブルにはページテーブルの基底アドレスとサイズが保存されている．
  1. ページ番号部が，セグメントテーブルから参照されたページテーブルのインデックス番号としてページテーブルを参照する．
  1. ページテーブルのページフレーム番号で主記憶上のページフレームを参照する．

## 多重レベルページング
- ページングを多段階に用意することでページテーブルを細かく分割可能にする．
- 主記憶領域へのアクセスは増加するものの，連想レジスタにより解決できる．

## 0レベルページング
- CPU内に，ハードウェアとしてのMMUを持たないページングシステム．
- ソフトウェア割り込みを利用してページテーブルを参照する．
- 主記憶領域の使用量が多いと，低速になる．
- ハードウェア的にはCPUのゲートが削減され，高クロック化する．

## ページフォールト割り込み
- 物理メモリが対応していない仮想アドレス空間上のページにアクセスした際に発生する割り込み．
- マイクロソフトはハードフォールトとも読んだりしている．

## スワップスケジューリング
- スワップイン，スワップアウトのスケジューリング
- 大きさが無限大の仮想アドレスを提供できる．
- スワップ操作に時間がかかる．
- 低頻度かつ低コストでなくてはならない．
  - ページフォールト割り込み時に行う．

## デマンドページング
- ページフォールトが発生した時点で行う．
  - 必要になった時に必要なページをスワップインすること．

## プリページング
- 必要になりそうなページを前もってスワップインする．
- 予測が当たればページフォールトは発生せずにコストが削減できる．
  - デマンドプリフェッチ
    - ページフォールトを起こした対象ページはスワップインする．
    - 将来必要とされる数ページを同時にスワップインする．
  - 初期ロードプリフェッチ
    - プログラムが最初にロードされるタイミングに実行される．
    - プログラム開始直後，近傍のページを同時にスワップインする．

## スワップアウトする場所
- 次にアクセスする確率が最も低いページ．
- 現時点からアクセスされる時間までの間隔が最も長いページ．
- 正確な算出は不可能である．
- 参照ビットを用いる．
  - ページテーブルにRフラグを導入する．
  - ページフォールト時に0にクリアされ，当該ページがアクセスされると1にセットされる．
  - スワップアウト候補の待ち行列を用意し，対象ページを決定する．

## 参照頻度表
- 過去の参照記録．
- 待ち行列よりも正確な参照頻度の算出が可能．
- 検索コストが増加する．

## 更新タイミング変更
- 更新タイミングの時間間隔を調整する．
  - 待ち行列のシフト操作と参照ビットのクリア頻度を変更する．
  - ページフォールト時よりも高頻度に対応．
  - 更新コストが増大．

## フェーズ化現象
- 以下の2点の特徴を持つアクセスパターン．
  - 空間的局所性を持つ．
  - ある時刻を境にプログラムがアクセスするページが急に切り替わる．
- 対応
  - フェーズ内では可能な限りスワップを発生させないページ割り当てアルゴリズムを導入する．
  - フェーズ繊維時間が微小なため，フェーズについては対策の必要なし．

# ファイル
## ファイルによる2次記憶の管理
- 2次記憶: フラッシュメモリ，HDD，磁気テープ，光ディスクなど．
- ファイル
  - 任意の時点で作成可能
  - 大きさを拡大，縮小可能．
  - プロセス間で共有可能．
  - 大きさの制限なし(2次記憶領域の大きさを超えない限り)．
- ファイル名
  - 自由に設定できる．
  - リンクにより同一ファイルを複数名で参照可能．

## テープ型デバイス
- 順次アクセス方式である．
  - テープの先頭(BOT)まで巻き戻せる．
  - ファイルの終わり(EOF)までテープヘッドを進める．
- 安価で大容量．
- ヘリカル・スキャン方式
  - テープ全体を，斜めにトラックを記録する仕組み．
  - 9,000rpm
  - ヘッドがテープをヘリカル(螺旋状)にスキャンしながら記録する．
  - 2つのWriteヘッドが[**アジマス角(Azimuth angle)**](#アジマス角)にセットされ，隣接するデータトラック間の混信を抑制．

## アジマス角
- Azimuth angle
- 磁気ヘッドの間隙(ヘッドギャップ)の向きとトラックの走行方向のなす角度のこと．

## ディスク型デバイス
- 直接アクセス方式である．
  - ランダムアクセスできる．
  - シリンダを回転させる．
  - シーク速度がやや遅い．
- 同心円状をトラックという単位で分割する．
- トラックをセクタという単位で分割する．
- 回転軸状の同一のトラックシリンダと呼ぶ．

## 階層化ディレクトリシステム
- ファイル名重複の問題を解決する．
  - `/home/tarheel/.zshrc`
  - `/home/winston/.zshrc`

## リンク
- シンボリックリンク
  - ファイル実態へのポインタではなく，ファイル名のパス情報で参照する．
  - ファイルが削除されても残る．
  - `$ ln -s ファイル リンク名`
- ハードリンク
  - ファイルの実態を複数のディレクトリファイルが指す．
  - ファイルが削除されるとハードリンクも削除される．
  - `$ ln ファイル リンク名`

## 固定長割り当て方式
- プロセスが必要とする量の二時記憶領域を1セクタ或いは1クラスタ単位で割り当てる．
- 複数の単位領域を一つの領域として扱う仕組みが必要である．
  - リスト方式
  - インデックス方式
- 複数領域を連結するため再構成オーバヘッドが存在する．

## 連続領域割り当て方式
- プロセス実行前に，必要となる大きさの連続したセクタを割り当てる．
- ヘッド回転数が減少する．
- 相対位置がわかりやすいためランダムアクセスが容易である．

## ディスクキャッシュ
- CPUと2次記憶装置とのアクセス速度の差により，CPUの動作クロックに対して膨大な待ち時間が発生する．
  - ディスクアクセスの遅さを改善する．

## ライトスルー方式
- 書き込み発生時にディスクキャッシュに加え，ディスクにも書き込む．
- 書き込みは高速化されない．

## ライトバック方式
- 書き込み発生時にディスクキャッシュのみに書き込みを行う．
- 書き込みは高速化される．

## 非同期入出力
- プログラムが実行する入出力命令を待たずに次の命令を実行する方式．
- 入出力待ちがない命令を先行して実行する．

## ファイルシステムの仮想化
- ディスクキャッシュ
  - ディスク上のデータを一部主記憶に置くことで低速なディスクへの読み書きを主記憶アクセス時間で実現する．
- ステージング
  - テープ等のデータを一部ハードディスクに置くことで低速な2次記憶への読み書きを比較的高速なハードディスクへのアクセス時間で実現する．
- アクセス頻度の低いデータは低速だが安価，大容量な記憶メディアに転送する．
  - OSやよく使うデータ，プログラムはSSDに置く．
  - 写真や動画データはHDDに置く．

## FAT(File Allocation Table)
- インデックス方式により，複数セクタを1クラスタとして管理する．
- BPB(ブートセクタ)からFATのバックアップがあり，ルートディレクトリ，データ領域と並ぶ．
- ディレクトリの各エントリは32byteで構成される．

## i-node
- インデックス方式を採用し，クラスタ領域を管理する．
- ファイルの作成日時や更新日時を管理する．

## ext3(Third Extended File System)
- クラスタの位置を示すポインタ情報を格納する15エントリが存在する．
  - 12エントリは直接クラスタ番号．
  - 3エントリは関節ブロックへのアクセス情報．

## ジャーナリング
- 書き換え処理要求単位で，メタデータを管理，保持できる機能を持ったファイルシステム．
- 複数の情報更新中にOSが突然停止となるようなファイルが不整合となる原因に対処できる．

