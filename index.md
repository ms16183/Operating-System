# オペレーティングシステムの役割
- 演算装置: データに対する演算を行う．
- 制御装置: 核装置を制御する制御信号を出す．
- 記憶装置: プログラムやデータを記憶する．
- 入力装置: コンピュータに外部からデータを入力する．
- 出力装置: コンピュータから外部にデータを出力する．
- LSI: Large Scale Integrated circuit．1チップの大規模集積回路．
- MPU: Licro Processing Unit．マイクロプロセッサ．
- 4004: 1971年にIntelがリリースした4bitCPU．
- 8086: 1978年に8bitCPU．x86の基礎．

# 主記憶装置
- 揮発性メモリ RAM(Random Access Memory)
  - DRAM(Dynamic RAM)
  - SRAM(Static RAM)

- 不揮発性メモリ ROM(Read Only Memory)
  - マスクROM
  - PROM(Programmable ROM)
  - EPROM(Erastable PROM)
  - EEPROM(Electrical EPROM)

# 補助記憶装置
- 補助記憶装置
  - HDD(Hard Disk Drive)
  - SSD(Solid State Drive)
  - ODD(Optical Disk Drive)

# OS
- アプリケーションプログラムにとって容易かつ効率的に利用可能とする一連のプログラムのこと．基本プログラムと呼ぶ．
- ハードウェアリソース: CPU，メモリ，入出力装置
- ソフトウェアリソース: ソフトウェアの使用権など
- 応用プログラム: ブラウザ，ワープロソフト，シェル
- オペーレーティングシステムの目的: **"容易性"と"効率性"の向上**である．

# 容易性
- ハードウェアへのアクセス
  - プログラム側がハードウェア操作しやすくなるインターフェイスを用意．
  - 入出力装置に対する簡単なアクセス．
- ハードウェアリソースの確保
  - プログラム別にハードウェアリソースの確保に対する制御．
  - 仮想化による無数のハードウェアリソースを提供する．

# 効率性
- ハードウェアリソースの共有
  - プログラムアクセス時の適切なスケジューリング
- ソフトウェアリソース管理
  - 最低限のソフトウェア実行，ソフトウェアリソースのバージョン管理
- プログラミング作成支援
  - ライブラリ管理，ユーザインターフェイス支援．
- 統合的なコンピュータシステム環境
  - ネットワークに結合したコンピュータのハードウェア・ソフトウェアリソース．
    - 例えばプリンタ．LAN内のPCから印刷できる．

# ハードウェアリソースの多重化と効率化
- 時分割多重化
  - 時間軸で多重化．ハードウェアリソースを複数プログラムに交互利用．
- 空間分割多重化
  - 空間軸場での多重化．ハードウェアリソースを複数の領域に区切り各プログラムに割り当てる．
    - メモリはこの例である．

- バッチ処理: プログラム実行前に一括投入されたジョブに含まれる情報のみによって処理を行う方式．
  - **ターンアラウンドタイム**: ジョブが待ち行列に投入されてから終了するまでの時間．
  - 実行に必要なリソースが小さいジョブを優先すると平均TATが少なくなって効率的である．
- インタラクティブ処理: プログラム実行中ウニ入力が必要となった時，ユーザの入力を行いプログラムの実行を制御する処理方式．
  - **スループット**: コンピュータが単位時間当たりに処理できる能力．
  - **TSS**: 複数のプロセスに非常に短い時間単位でCPUの実行権を与えて，各プロセスにCPUを占有させているように見せかける仮想化手法．
  - **レスポンスタイム**: インタラクティブな入力を受けて処理結果を返却するまでの時間．
  - スパコンではバッチ処理が優先される．メインフレームでは対話処理にリソースを優先．

# リアルタイム処理
- ジョブやプロセスが発生し，決められた時間内に実行を保証．
- レスポンスタイムの変動要素をできる限り排除．
- リアルタイム性を担保できるハードウェアリソース．
  - 工場のロボット制御．
  - 音声・映像のメディア処理．
  - ATMシステム，飛行機の予約システム．

# 分散処理
- ネットワークを通じて複数のコンピュータを同時に用いて処理を行う．
- クライアントサーバモデル．
- コンピュータ間でのファイル共有．
- 分散コンピューティング．

<!-- # CPUの仮想化 -->

# プロセスとその処理形態
- プロセス: 実行プログラムに対するリソースの割り当て単位
- ユニプロセッサ・ユニプログラミング方式
  - 1個のCPU上で一つのプロセスの開始から終了までを継続して処理する．
- ユニプロセッサ・マルチプログラミング方式
  - 主記憶内に複数のプログラムを格納し，入出力の完了またはOSからの命令によりプログラムを切り替えて実行する．
- マルチプロセッサ・マルチプログラミング方式
  - 複数のCPUを備えたコンピュータを対象とし，複数CPUで同時にプログラムを実行する．
- スレッド・CPUリソースを論理的な単位で割り当て
  - プロセスは多数のスレッドを内部に生成できる．
  - 複数スレッドは同時実行される複数の実行ポイントが存在する．
  - プログラムに並列性がある場合，一つのプロセス内で同時に複数CPUを使用可能．

# プロセスの状態
- **実行状態(running)**
  - CPUリソースを含む実行に必要なすべてのリソースが確保され，プロセスを実行している状態．
- **実行可能状態(ready)**
  - CPUリソースさえ確保できればプロセスを実行可能な状態．
- **待ち状態(wait)**
  - CPU以外に実行に必要なリソースが確保されていない状態．

# 割り込み
- 割り込み処理
  - CPUが高速化つ軽量にイベントを処理するプログラム実行方式．
    - イベントは，CPU内で通常の計算処理以外の事象．
  - 内部割り込み
    - SVC割り込み
    - プログラムチェック割り込み
  - 外部割り込み
    - 入出力割り込み
    - タイマ割り込み
    - マシンチェック割り込み
    - リスタート割り込み
- 実行速度の差
  - 人の反応速度: 約10^(-1) sec
  - HDDのR/W速度: 約10^(-3) sec
  - メモリのR/W速度: 約10^(-7) sec
  - CPUの1命令実行速度: 約10^(-9) sec

# スーパバイザコール割り込み
- スーパバイザコール(SVC)割り込み
  - ユーザプログラムがOSに対して処理を依頼する際に発生する割り込み．
  - 入出力関数内でSVC割り込みを呼び出し，OSへ処理を依頼する．
  - スーパバイザモード
    - OSを実行するモードをCPUが有するすべての命令とOSが管理するすべてのリソースを利用可能．
  - ユーザモード
    - ユーザが作成した応用プログラムを実行するモード．実行できる命令や利用リソースに制限あり．
- プログラムチェック割り込み(例外割り込み)
 - 実行中のプログラムで異常が発生した時に発生する割り込み．
  - ゼロ除算
  - オーバーフロー
  - 不正アドレスアクセス
- プログラム実行時の異常を適切に対処することが可能．

# 外部割り込み
- 入出力割り込み
  - 入出力装置から発生する割り込み．
  - OSが2次記憶装置に書き込み依頼し，書き込みが終了した際に発生する2次記憶装置からの割り込み．
- タイマ割り込み
  - タイムシェアリングシステムにおいて，各プロセスに割り当てられたクオンタムの終了時など，時間を制御するインターバルタイマによる割り込み．
- マシンチェック割り込み
  - ハードウェアによって通知される異常．
    - CPU温度上昇
    - 冷却装置の異常
    - その他電源などの異常
- リスタート割り込み
  - コンピュータシステムをリスタート(リセット)する際に発生する割り込み．

# 割り込みによるプロセスの中断と再開
- 割り込みが発生すると，実行中のプロセスが中断され，割り込み処理ルーチン(割り込みハンドラ，割り込み処理プログラム)が実行される．
  - プロセスAがCPUスケジューラに対して入出力命令を依頼して割り込みが発生(SVC命令)．

# スレッド
- CPUリソースのみを独立に割り当てる．
  - マルチスレッド
    - 各スレッドは独自にレジスタ軍とスタックを持ち，CPUリソースを割り当てる．
    - プロセス内で管理される主記憶，プログラム領域，静的変数領域，動的変数領域，PSWが各スレッド間で共有する．
    - ファイル情報もプロセス単位で管理する．
    - CPU内に複数のコアがある場合，それぞれでスレッドを作成し，並列実行が可能．

# 実行中のプロセスの中断方式
- **プリエンプション方式**
  - OSが実行中のプロセスの実行権を強制的に取り上げプロセスを中断する．
  - プリエンティブなマルチタスク(Win, Mac, UNIXが採用)

- **ノンプリエンプション方式**
  - OSではなく実行中のプロセスが**自主的**にCPUリソースをOSに戻す．
  - プログラムが暴走した場合，プロセスが自主的にCPUリソースを変換できずシステム団の可能性あり．
  - ノンプリエンプテなマルチタスク(Win95, MacOS9が採用)

- OSの効率性は，CPUスケジューリングアルゴリズムの性能でほぼ決定する．
  - 理想は応答時間・待ち時間が最小，CPU使用率・スループットが最大．
- CPUリソースは時間分割し仮想化する．
  - プロセスの切り替えが増加．
  - 次に実行するプロセスを選択する操作も増加．
- 切り替えによるオーバヘッドの増加．
  - コンピュータシステムのスループットが低下．
  - スケジューリング方法でオーバーヘッドの増減を調整．

- スケジューリングアルゴリズムの効率化の指標
  - 応答時間
    - **ターンアラウンドタイム**: パッチ処理におけるジョブ投入から結果受け取りまでの時間．
    - レスポンスタイム: 対話処理における端末からの入力から結果受け取りまでの時間．
  - **スループット**
    - CPUが単位時間に行うユーザに有益な仕事量．
    - プロセス切り替えなどのオーバヘッドは含まれない．
    - 入出力操作やコンテキスト切り替えなどを提言し計算処理にCPUリソースを用いるとスループットが向上．
  - 待ち時間
    - プロセスが完了するまでに実行可能キューで待つ時間(実行可能状態から実行できるまでの時間)
  - CPU使用率
    - `CPUの動作時間 / システム稼働時間`

# 到着順スケジューリング
- FIFO方式である．
- 最初に到着したプロセスが終了までリソースを占有する．プロセスの処理時間を考慮しない．
- 到着順をA, B, Cとするとき平均ターンアラウンドタイムは
  - `(Aのプロセス時間 + (累積のプロセス処理時間-Bの開始時間) + (累積のプロセス時間-Cの開始時間)) / 3`

# 処理時間順スケジューリング
- プロセスの処理時間が小さいものから割り当てる方式．
- 実際は，各プロセスの処理時間を事前に知ることはできない．
- 応答時間を理論上で最短にできる．

# 優先度順スケジューリング
- 優先度を**nice**という値で決める．
- niceが小さいほど優先度が高い．
- 動的優先度
  - プロセス実行中に優先度が変化するスケジューリング．
  - 既実行時間，待ち時間で優先度を変化させる．
  - 入出力操作直後のプロセスに対して優先度を高くする．
  - スタベーション: プロセスの待ち時間に応じて優先度を変化させるエージング方式による動的優先スケジューリングを適用する．
- 静的優先度
  - プロセス生成時にあらかじめ指定した優先度によってスケジューリングを行う．

# ラウンドロビンスケジューリング
- 実行中プロセスにクオンタムが割り当てられる．これを使い果たすとプリエンプションする．
- 割り当てCPU利用可能時間(クオンタム)終了後，CPUスケジューラの割り込みでプロセスを中断し，待ち行列の末尾に追加する．

# 多重レベルフィードバックスケジューリング
- 優先度で分けられた複数の待ち行列を用いる．
- クオンタムを得たプロセスは優先度が低い待ち行列に移される
- 複数のクオンタムを必要とするプロセスは優先度が下がる．

<!-- # 並行プロセス -->

# 並行プロセス
- プロセス競合
  - 有限なリソースを取り合う状態．
  - 適切にリソースを割り当てなければならない．
- プロセス協調
  - 複数プロセスがお互いを助け合う処理．
  - 複数プロセスが同期している．
- プロセス干渉
  - 他プロセスの影響により現在のプロセスに異常が発生する状態．
  - プログラムのバグが原因であることが多い．

# プロセス競合
- リソースに関する共有変数があるとする．
  - プロセスAが共有変数をリードし，ライトするまでの間にプリエンプションなどによりプロセスBが共有変数を読んでしまう．
    - **クリティカルセクション**: ロード，ストア間などアトミックにしなければならない一連の処理．
    - **MUTEX**: クリティカルセクション等を他のプロセスと排他的に実行する制御のこと．

# プロセス協調
- プロセス間通信
  - 通信の仕組みがない場合，送受信双方でタイミングを合わせる．
    - フラグによって送信をしなかったり受信をしなかったりする．
    - 通信バッファを設けて一時的に通信情報を保存する．

# プロセス干渉
- 緊急度の高いプロセスが実行されたため，別プロセスがスワップアウトされる場合など．

# 排他制御
- MUTEX
- 即時性
  - クリティカルセクションの実行時に競合するプロセスが存在しないとき，プロセスは即クリティカルセクションを行うようにする．
- 公平性
  - 他プロセスのクリティカルセクションの実行を妨げることができない．
- デッドロック防止
  - 競合プロセスが存在しようとも，永遠に待たされることがない．

- エントリーシーケンス(Entry Sequence)
  - クリティカルセクションに入る権利を獲得する処理．
  - クリティカルセクションをフラグで管理し，クリティカルセクション開始時にフラグを変更する．

- エグジットシーケンス(Exit Sequence)
  - クリティカルセクションを終了する準備を行う処理．

# Dekkerのアルゴリズム(排他制御)
- Interest
  - 2つのプロセスがクリティカルセクションに興味があるかを示す．
- Priority
  - 2つのプロセスがクリティカルセクションに同時に興味があった場合，どちらが優先するかを決める．
- 問題点
  - ユーザプログラムに依存し過ぎている．
  - クリティカルセクション実行中，片方のプロセスはずっと待ち状態であるためCPUリソースを無駄に消費する**ビジーウェイト**に陥る．
    - **スピンロック**: 複数プロセスの場合，積極的にこの待ち方をする．
  - 3つ以上のプロセスが同時に実行される環境では細かい優先度設定が困難である．
  - OoO実行とは反する．

# 割り込み制御による排他制御
- 割り込みのみがプロセスの中断を発生させる．
  - そのためクリティカルセクション実行時のエントリーシーケンスで，割り込み実行禁止命令を実行する．
  - エグジットシーケンスで割り込み実行禁止命令が解除される．
- 問題点
  - 大規模システムだと，頻繁に割り込みが発生する．
  - 割り込み実行禁止が増えるとOSの実行自由度が低下する．
  - OS停止の可能性がある．

# ハードウェアによる排他制御
- テストアンドセット命令
  - TAS命令
  - あるメモリ位置へアトミックに書き込みできる命令．
    - つまり，プリエンプションが行われない．
  - Dekkerのアルゴリズムよりも単純である．

# セマフォ(Semaphore)
- ダイクストラが提案したプログラミングの手法．オランダ語で"視覚による信号"が語源．
- プロセス間同期機構
  - 整数型であるセマフォ変数，待ち行列からなる構造体である．
  - P操作: リソースの獲得．許可されない場合は待ち状態へ移行する．セマフォ変数をデクリメントする．
  - V操作: リソースの解放．まちプロセスを実行可能状態へ移行する．セマフォ変数をインクリメントする．

# プロセス協調問題
- [MUTEX](#MUTEX)
- [プロデューサ・コンシューマ問題](#プロデューサコンシューマ問題)
- [リーダライタ問題](#リーダライタ問題)
- [ダイニングフィロソフィア問題](#ダイニングフィロソフィア問題)

# MUTEX
- セマフォによる排他制御．

```
Semaphore mutex = 1;

P(mutex); // -
// クリティカルセクション
V(mutex); // +
```

# プロデューサ・コンシューマ問題
- [プロセス協調](#プロセス協調)の例と同じ．
  - フラグで送受信を管理する．
- リング型バッファ
  - バッファをn個設ける．
  - 送信側はバッファ`i`番に送信データを書き込んで，`i`の値を増加．
  - 受信側はバッファ`j`番に受信データを読み込んで，`j`の値を増加．
  - n-1番は0番に繋がっている(つまり，`i=(i+1)%n`, `j=(j+1)%n`である)．
  - リング上を送信側と受信側が回っていて，データを書き込んだり読み込んだりしているように見える．

# リーダライタ問題
- ライタによる書き込み中はリーダは読み込めない．
- ライタが書き込みを行なっていない場合，複数のリーダが読み出し可能．
- リーダとは反対に，同時に複数のライタを使用できない．

# ダイニングフィロソフィア問題
- 5台のコンピュータが5台のテープ装置に競合アクセスする同期問題のモデル．
- Candy/Misraの解法を用いれば，任意のプロセス，任意のリソースの確保可能かつデッドロックが発生しないアルゴリズム．

# モニタ
- セマフォとオブジェクト指向プログラミングによる排他制御．
- モニタ内へのリソースにアクセスする場合はコンパイル時にチェックされる．

```
class Monitor{
  private int num;

  public Monitor(int n){
    num = n;
  }

  void increment(){
    num += 1;
  }

  void decrement(){
    num -= 1;
  }
}

// 複数プロセスに共有される．
Monitor monitor = new Monitor(1);

monitor.decrement();
// クリティカルセクション
monitor.increment();
```

- 共有変数へのアクセスはメソッドからのみ．
- 排他制御のためのコードを記述しなくても良い．

# モニタによるLock機構

```
class Monitor{
  private int reader;
  private int writer;
  private bool busy;

  void Monitor(){
    reader = 0;
    writer = 0;
    busy = false;
  }

  public void start_read(){
    while(writer != 0){
      reader += 1;
    }
  }

  public void finish_read(){
    if(reader >= 1){
      reader -= 1;
    }
  }

  public void start_write(){
    writer += 1;
    while(busy || reader != 0){};
    busy = true;
  }

  publiv void finish_write(){
    if(writer >= 1){
      writer -= 1;
    }
    busy = false;
  }
}

// Lock機構
Monitor lock;
```

# モニタによるCondition機構

```
class Monitor{
  // 待ち行列
  private Mat mat;

  public Monitor(mat m){
    mat = m;
  }

  // 別プロセスが待ち状態に移行する原因となった条件変数に対して
  // signalを実行するまで自分は待ち状態に移行する．
  public void wait(){
    // プロセスを待ち行列に追加する．
  }

  // 条件変数にしたいしてwaitメソッドを実行したことにより待ち状態のプロセスがある場合は
  // そのうちの1つを実行可能状態にする．
  public void signal(){
    // 待ち行列からプロセスを選択する．
    // 選択したプロセスは実行可能である．
  }

  // シグナル全プロセスバージョン
  public void signal_all(){
    // 待ち行列のプロセスを全て実行可能にする．
  }

  // 待ち状態のプロセスが存在するか否か．
  public bool queue(){
    // 待ち行列にプロセスが存在するか否か．
    return mat.length > 0;
  }
}

// Condition機構
Monitor cond;
```

# モニタの利点と欠点
- 利点
  - 排他制御するべきリソースを明示化できる．
  - オブジェクト指向であるため可読性，保守性が高い．
  - リソースに空きがない場合，待ち状態になるか否かを自由に選択できる．
  - コンパイル時にエラーが検出できる(ただし完璧ではない)．

- 欠点
  - モニタを言語レベルでサポートしているものは少ない．
    - Java
    - Mesa
    - Python，NET Framework，Squeak Smalltalkではライブラリがある．
